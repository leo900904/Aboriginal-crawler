# 新頁面爬蟲開發指南

環境：直接使用
conda env create -f environment.yml
和 
conda activate aborigin-beautifulsoup

## 概述

本指南詳細說明如何為 klokah.tw 原住民語學習網站開發新頁面的爬蟲程式。所有爬蟲都遵循統一的架構模式，確保音檔和文字的正確對應。

## 專案結構

```
Aborigin爬蟲/
├── main.py                    # 主程式，包含所有爬蟲的統一入口
├── crawlers/                  # 爬蟲模組目錄
│   ├── __init__.py           # 模組初始化文件
│   ├── utils.py              # 共用工具函數
│   ├── state.py              # 全域狀態管理
│   ├── alphabet_crawler.py   # 字母篇爬蟲（靜態音檔範例）
│   ├── dialogue_crawler.py   # 情境族語爬蟲（動態音檔範例）
│   ├── essay_crawler.py      # 族語短文爬蟲
│   ├── sentence_crawler.py   # 句型篇爬蟲
│   ├── vocabulary_crawler.py # 學習詞表爬蟲
│   └── ...                   # 其他專業爬蟲
└── collect_env_info.py       # 環境資訊收集工具
```

## 目前缺少的頁面爬蟲

根據 main.py 中的註釋，還需要開發以下頁面的爬蟲：

### 補充教材
- **閱讀文本** - 需要開發 `reading_text_crawler.py`

### 教材教具學習
- **WAWA點點樂** - 需要開發 `wawa_game_crawler.py`
- **主題式掛圖** (身體、親屬、山川自然、動物) - 需要開發 `thematic_chart_crawler.py`
- **LIMA有聲書** - 需要開發 `lima_audiobook_crawler.py`

### 開放平台
- **繪本平台** - 需要開發 `picture_book_crawler.py`
- **動畫平台** - 需要開發 `animation_crawler.py`
- **影音中心** - 需要開發 `media_center_crawler.py`
- **自編教材** - 需要開發 `self_compiled_materials_crawler.py`
- **教案平台** - 需要開發 `lesson_plan_crawler.py`
- **句法演練平台** - 需要開發 `syntax_practice_crawler.py`

## 新爬蟲開發流程

### 第一步：分析目標頁面

1. **訪問目標網址**：使用瀏覽器訪問要爬取的頁面
2. **F12 開發者工具分析**：
   - **Network 面板**：觀察音檔載入方式
     - 靜態音檔：直接在 HTML 中有 `<audio>` 或 `<a href="*.mp3">` 標籤
     - 動態音檔：透過 JavaScript 請求，在 Network 中觀察 XHR/Fetch 請求
   - **Elements 面板**：分析頁面結構和文字元素位置
   - **Console 面板**：測試 JavaScript 選擇器

### 第二步：建立爬蟲文件

在 `crawlers/` 目錄下建立新的爬蟲文件，命名格式為 `{功能名稱}_crawler.py`

#### 基本模板結構：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import time
import logging
import re
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import NoSuchElementException, TimeoutException
from crawlers.utils import download_audio, save_label, clean_romaji
from crawlers.state import CREATED_FOLDERS

def crawl_your_function_name(driver, main_lang, dialect, folder_name):
    """
    爬取功能的主函數
    
    Args:
        driver: Selenium WebDriver 實例
        main_lang: 主語言名稱 (例如: "泰雅語")
        dialect: 方言名稱 (例如: "賽考利克泰雅語") 
        folder_name: 資料夾名稱 (例如: "新功能")
    """
    
    # 1. 建立資料夾結構
    topic_folder = os.path.join(main_lang, dialect, folder_name)
    os.makedirs(topic_folder, exist_ok=True)
    
    record_folder = os.path.join(topic_folder, f"{folder_name}-10")
    os.makedirs(record_folder, exist_ok=True)
    
    audio_folder = os.path.join(record_folder, "audio")
    os.makedirs(audio_folder, exist_ok=True)
    
    label_file = os.path.join(record_folder, "label.txt")
    CREATED_FOLDERS.add(record_folder)
    
    # 初始化 label.txt
    with open(label_file, "w", encoding="utf-8") as f:
        f.write("")
    
    # 2. 計算音檔編號起始值
    counter = len([f for f in os.listdir(audio_folder) if f.lower().endswith('.mp3')]) + 1
    
    try:
        # 3. 爬取邏輯實作
        # ... 在這裡實作你的爬取邏輯
        pass
        
    except Exception as e:
        logging.error(f"爬取 {folder_name} 時出錯: {e}")
```

### 第三步：音檔處理策略

#### 靜態音檔處理（參考 alphabet_crawler.py）

```python
# 直接從 HTML 元素獲取音檔 URL
try:
    audio_tag = driver.find_element(By.CSS_SELECTOR, "a.audio-link")
    audio_url = audio_tag.get_attribute("href")
    
    mp3_name = f"{counter:04d}.mp3"
    download_audio(audio_url, mp3_name, audio_folder)
    
    # 儲存文字標籤
    save_label(text_content, mp3_name, label_file)
    counter += 1
    
except Exception as e:
    logging.warning(f"靜態音檔下載失敗: {e}")
```

#### 動態音檔處理（參考 dialogue_crawler.py）

```python
# 方法1：從預載的 audioSet 獲取音檔
def get_audio_mapping(driver):
    """獲取頁面預載的音檔映射"""
    audio_map = {}
    try:
        audio_set = driver.find_element(By.ID, "audioSet")
        audio_tags = audio_set.find_elements(By.CSS_SELECTOR, "audio.player-ab")
        for audio in audio_tags:
            data_value = audio.get_attribute("data-value")
            try:
                source = audio.find_element(By.TAG_NAME, "source")
                src = source.get_attribute("src")
                audio_map[data_value] = src
                logging.info(f"音檔映射: {data_value} -> {src}")
            except Exception:
                continue
    except Exception as e:
        logging.warning(f"找不到 audioSet: {e}")
    return audio_map

# 使用音檔映射
audio_map = get_audio_mapping(driver)
play_btn = element.find_element(By.CSS_SELECTOR, "button.sound-btn")
data_value = play_btn.get_attribute("data-value")

if data_value and data_value in audio_map:
    audio_src = audio_map[data_value]
    download_audio(audio_src, mp3_name, audio_folder)
```

```python
# 方法2：使用 Selenium Wire 監聽網路請求
# 在 main.py 中已經使用 seleniumwire.webdriver

# 點擊播放按鈕觸發音檔請求
play_button.click()
time.sleep(1)

# 從網路請求中找到音檔
for request in driver.requests:
    if request.response and 'audio' in request.response.headers.get('content-type', ''):
        audio_content = request.response.body
        with open(os.path.join(audio_folder, mp3_name), 'wb') as f:
            f.write(audio_content)
        break
```

### 第四步：文字與音檔對應

確保文字和音檔的正確對應是關鍵：

```python
# 範例：處理原住民語和中文對應
try:
    # 提取原住民語文字
    aboriginal_text = driver.find_element(By.CSS_SELECTOR, ".aboriginal-text").text.strip()
    
    # 提取中文翻譯
    chinese_text = driver.find_element(By.CSS_SELECTOR, ".chinese-text").text.strip()
    
    # 清理文字（移除不必要的符號）
    aboriginal_clean = re.sub(r'\([^)]*\)', '', aboriginal_text).strip()
    chinese_clean = re.sub(r'\([^)]*\)', '', chinese_text).strip()
    
    # 組合格式：中文(原住民語)
    combined_text = f"{chinese_clean}({aboriginal_clean})"
    
    # 儲存到 label.txt
    mp3_name = f"{counter:04d}.mp3"
    with open(label_file, "a", encoding="utf-8") as f:
        f.write(f"{mp3_name}\n")
        f.write(f"{combined_text}\n")
        f.write("male\n")
        f.write("one\n")
        f.write("\n")
        
except Exception as e:
    logging.error(f"文字提取失敗: {e}")
```

### 第五步：在 main.py 中註冊爬蟲

1. **添加導入語句**（在檔案開頭）：
```python
from crawlers.your_new_crawler import crawl_your_function_name
```

2. **在 crawlers 字典中添加配置**：
```python
crawlers = {
    # ... 現有的爬蟲配置 ...
    
    '你的新功能名稱': {
        'url': 'https://web.klokah.tw/your-new-page/',
        'func': crawl_your_function_name,
        'folder': '你的新功能名稱'
    },
}
```

3. **測試單一爬蟲時，註解其他爬蟲**：
```python
# 在 main() 函數中，暫時註解掉其他爬蟲配置
for name, config in crawlers.items():
    if name != '你的新功能名稱':  # 只執行你要測試的爬蟲
        continue
    # ... 爬取邏輯
```

### 第六步：錯誤處理和日誌

```python
import logging

# 在函數開始時記錄
logging.info(f"開始爬取 {folder_name}")

# 在關鍵步驟添加日誌
logging.info(f"找到 {len(elements)} 個元素")

# 錯誤處理
try:
    # 爬取邏輯
    pass
except TimeoutException:
    logging.warning("等待元素超時")
except NoSuchElementException:
    logging.warning("找不到指定元素")
except Exception as e:
    logging.error(f"未預期的錯誤: {e}")
```

## 常見問題與解決方案

### 1. 頁面載入緩慢
```python
# 增加等待時間
WebDriverWait(driver, 30).until(
    EC.presence_of_element_located((By.CSS_SELECTOR, "your-selector"))
)
```

### 2. 動態內容載入
```python
# 等待特定內容變化
WebDriverWait(driver, 10).until(
    lambda d: d.find_element(By.CSS_SELECTOR, ".content").text != old_content
)
```

### 3. 音檔格式轉換
```python
# 如果遇到 WAV 格式，需要轉換為 MP3
def convert_wav_to_mp3(wav_data, output_mp3_path):
    import subprocess
    import tempfile
    
    with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_wav:
        temp_wav.write(wav_data)
        temp_wav_path = temp_wav.name

    subprocess.run([
        'ffmpeg', '-i', temp_wav_path,
        '-acodec', 'libmp3lame', '-y',
        output_mp3_path
    ], check=True, capture_output=True)
    
    os.unlink(temp_wav_path)
```

### 4. iframe 處理
```python
# 如果內容在 iframe 中
iframe = driver.find_element(By.CSS_SELECTOR, "iframe")
driver.switch_to.frame(iframe)

# 爬取 iframe 內容
# ...

# 切回主頁面
driver.switch_to.default_content()
```

## 測試和除錯

1. **使用 driver.save_screenshot('debug.png')** 在關鍵步驟截圖
2. **添加 time.sleep() 觀察頁面變化**
3. **使用 print() 或 logging.info() 輸出中間結果**
4. **在瀏覽器開發者工具中先測試選擇器**

## 音檔類型識別與處理策略 🎵

### 音檔的兩種類型

#### 🔗 靜態音檔（Static Audio Files）
**特徵**：
- HTML 中直接包含音檔的完整 URL
- 通常以 `<audio>` 標籤或 `<a href="*.mp3">` 形式出現  
- 音檔 URL 在頁面載入時就已確定
- 可以直接右鍵複製音檔連結

**識別方法**：
```html
<!-- 範例1：audio 標籤 -->
<audio controls>
    <source src="audio/word001.mp3" type="audio/mpeg">
</audio>

<!-- 範例2：連結標籤 -->
<a href="sounds/pronunciation.mp3" class="audio-link">播放</a>

<!-- 範例3：按鈕帶有音檔屬性 -->
<button data-audio="media/sample.mp3" class="play-btn">▶️</button>
```

**處理方式**：
```python
# 直接獲取音檔 URL 並下載
try:
    # 方法1：從 audio 標籤獲取
    audio_element = driver.find_element(By.CSS_SELECTOR, "audio source")
    audio_url = audio_element.get_attribute("src")
    
    # 方法2：從連結獲取
    link_element = driver.find_element(By.CSS_SELECTOR, "a.audio-link")
    audio_url = link_element.get_attribute("href")
    
    # 直接下載
    download_audio(audio_url, mp3_name, audio_folder)
    
except Exception as e:
    logging.warning(f"靜態音檔處理失敗: {e}")
```

#### ⚡ 動態音檔（Dynamic Audio Files）
**特徵**：
- 音檔 URL 不在 HTML 中直接顯示
- 透過 JavaScript/AJAX 動態載入
- 需要點擊播放按鈕或觸發特定事件才會產生請求
- 音檔可能透過 API 呼叫或即時生成

**🔍 F12 開發者工具分析步驟**：
1. **打開 F12 → Network 面板**
2. **清空 Network 紀錄**（點擊垃圾桶圖示）
3. **點擊播放按鈕**
4. **觀察新增的網路請求**

```
🔍 在 Network 面板中尋找：
- Type: Media 或 XHR/Fetch
- 檔案類型：.mp3, .wav, .ogg 等
- Content-Type: audio/*
- 回應內容為音檔資料
```

**處理方法**：

**方法A：預載音檔映射（推薦）**
```python
def get_audio_mapping(driver):
    """獲取頁面預載的音檔映射"""
    audio_map = {}
    try:
        # 尋找隱藏的音檔容器（通常是 audioSet）
        audio_set = driver.find_element(By.ID, "audioSet") 
        audio_tags = audio_set.find_elements(By.CSS_SELECTOR, "audio.player-ab")
        
        for audio in audio_tags:
            data_value = audio.get_attribute("data-value")
            try:
                source = audio.find_element(By.TAG_NAME, "source")
                src = source.get_attribute("src")
                audio_map[data_value] = src
                logging.info(f"🎵 音檔映射: {data_value} -> {src}")
            except Exception:
                continue
                
    except Exception as e:
        logging.warning(f"找不到 audioSet: {e}")
    return audio_map

# 使用映射下載音檔
audio_map = get_audio_mapping(driver)
play_btn = driver.find_element(By.CSS_SELECTOR, "button.sound-btn")
data_value = play_btn.get_attribute("data-value")

if data_value and data_value in audio_map:
    audio_src = audio_map[data_value]
    download_audio(audio_src, mp3_name, audio_folder)
```

**方法B：Selenium Wire 網路監聽**
```python
# 清空之前的請求紀錄
driver.requests.clear()

# 點擊播放按鈕觸發音檔請求
play_button.click()
time.sleep(2)  # 等待請求完成

# 從網路請求中尋找音檔
for request in driver.requests:
    if request.response:
        content_type = request.response.headers.get('content-type', '')
        
        # 檢查是否為音檔
        if 'audio' in content_type or request.url.endswith(('.mp3', '.wav', '.ogg')):
            audio_content = request.response.body
            
            # 儲存音檔
            audio_path = os.path.join(audio_folder, mp3_name)
            with open(audio_path, 'wb') as f:
                f.write(audio_content)
            
            logging.info(f"📡 透過網路監聽下載: {mp3_name}")
            break
```

### 📋 實際專案範例

**alphabet_crawler.py（靜態音檔）**：
```python
# 字母篇 - 直接從 HTML 連結獲取音檔
audio_tag = driver.find_element(By.CSS_SELECTOR, "a.sm2_button.audio")
audio_url = audio_tag.get_attribute("href")  # 🔗 靜態連結
download_audio(audio_url, mp3_name, audio_folder)
```

**dialogue_crawler.py（動態音檔）**：
```python
# 情境族語 - 使用預載音檔映射
audio_map = get_audio_mapping(driver)  # ⚡ 動態映射
data_value = play_btn.get_attribute("data-value")
if data_value in audio_map:
    download_audio(audio_map[data_value], mp3_name, audio_folder)
```

### 🔍 判斷音檔類型的方法

**開發前的分析流程**：
1. **打開目標網頁**
2. **F12 → Elements**：搜尋 `audio`、`mp3`、`sound` 等關鍵字
3. **F12 → Network**：清空紀錄 → 點擊播放 → 觀察請求
4. **判斷**：
   - HTML 中有音檔 URL → **🔗 靜態音檔**
   - 點擊後才出現音檔請求 → **⚡ 動態音檔**

---

**注意事項**：
- 確保音檔和文字的對應關係正確 